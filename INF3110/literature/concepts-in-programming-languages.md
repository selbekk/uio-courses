# Notes on the book "Concepts in Programming Languages" by John C Mitchell (2003)

Book purchased in hardcover, in personal library

**Notes include Sec. 4.1; Chapters 5, 6, 7, 8, 9, 10, 11 and 15.**

## 4.1 - Compilers and Syntax
A compiler takes source code as input, and outputs the target program (where the target is the machine) to be interpreted by a machine

A compiler has several phases - or steps - to its process of making high-level code into machine-readable instructions

1. Lexical analyser
    - input is tokenized and recognized
    - left-to-right, top-to-bottom scan
    - does not differentiate between types, simply puts the input into recognized groups that it can sort through later
2. Syntax analyzer
    - Grouping into syntactical groups, like expressions , declarations and statements
    - Syntactical groups are tested for their compliance with the language's grammatical rules
    - Part of compiling called "parsing"
    - Creating a "parse tree" - data structure that models the syntactical structure of the program
3. Semantic analyser
    - Context-aware analysis of the code
    - "Is this assignment okay?", "Do I need to do a conversion here?" etc.
4. Intermediate code generator
    - Translates parse tree to a form of intermediary code
    - Intermediary code is easy to produce and easy to translate to machine code
5. Code optimizer
    - Several techniques that can be applied to code to optimize it
    - _Common Subexpression Elimination_ - Eliminating calculating the same calculation twice
    - _Copy Propagation_ - if ``x=y``, check if x can be eliminated by using y
    - _Dead Code Elimination_ - remove unreachable code
    - _Loop Optimization_ - optimize whatever happens inside loops
    - _Inlining Functions_ - minimising amount of code jumps by inlining what's inside different functions - if applicable
6. Code generator
    - Generating machine code
    - Perform memory optimalizations

### 4.1.2 - Grammars and parse trees

A **grammar** consists of a start symbol, a set of nonterminals, a set of terminals, and a set of productions (rules)

**Non-terminals** are symbols that are used to write out the grammar

**Terminals** are symbols actually generated by the grammar (the code)

A sequence of replacement steps resulting in a string of terminals is called a **derivation**.

**Parse trees** (or _derivation trees_) are a convenient way of displaying a derivation. Parse trees start with the _start symbol_, and is then evaluated downward.

**Precedence** and **associativety** are two parsing conventions usually adopted by most compilers today. Precedence can specify that i.e. the multiplication symbol ``*`` is more important than the addition symbol ``+``, and the compiler will then parse the expression ``2 * 2 - 2`` as ``(2 * 2) - 2``. Associativity (left or right) defines what happens when two operands have the same precedence. With left associativity, the expression ``1 + 1 - 1`` would be parsed as ``(1 + 1) - 1``, while with right associativity, the parser would assume ``1 + (1 - 1)``.
